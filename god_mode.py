# -*- coding: utf-8 -*-
"""God Mode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YWGIBPyD5gsEWUeqiC9srvwLzK8lYTDi
"""

#8. (3 puntos) El número de Sheldon: En la serie “Big Bang Theory” se conjeturó que el número 23 posee unas características únicas que no posee ningún otro número (link a la conjetura original). En 2019 Pomerance y Spicer demostraron que solo el 73 cumple las condiciones de la Conjetura de Sheldon (link a la desmostración). El ejercicio consistirá en comprobar que en los números entre el 1 y el 1 000 000 solo el 73 cumple la conjetura de Sheldon. Un número de Sheldon debe cumplir 3 propiedades:
# a. Es primo

import numpy as np

def es_primo(n):
    if n < 2:
        return False
    for i in range(2, int(np.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

# Prueba de la función
numero = 73
print(f"¿El número {numero} es primo?: {es_primo(numero)}")

#b. El producto de sus dígitos [llamemos a esta operación m()] es igual a su posición en la lista de todos los primos (empezando por el número 2). Por ejemplo: En 73, m(73) = 7*3 = 21 y en la lista de primos el 73 está en la posición 21ª (se puede comprobar con el ejercicio 6).

def es_primo(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

primos = []
limite = 1000
for num in range(2, limite + 1):
    if es_primo(num):
        primos.append(num)

# Verificar el producto de los dígitos de 73
numero = 73

def producto_digitos(n):
    producto = 1
    while n > 0:
        producto *= n % 10
        n //= 10
    return producto
# Producto de los dígitos de 73
producto_73 = producto_digitos(numero)
# Posición de 73 en la lista de números primos
posicion_73 = primos.index(numero) + 1
# Imprimir resultados
print(f"Producto de los dígitos de {numero}: {producto_73}")
print(f"Posición de {numero} en la lista de primos: {posicion_73}")
print(f"¿Cumple el número {numero} la condición b?: {producto_73 == posicion_73}")

def es_primo(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

# Generar lista de números primos hasta un número suficientemente grande
primos = []
limite = 1000
for num in range(2, limite + 1):
    if es_primo(num):
        primos.append(num)

# Función para calcular el número espejo
def espejo(n):
    return int(str(n)[::-1])

#Espejo de 73
numero = 73
espejo_73 = espejo(numero)

#Posición del 37 en la lista de primos
posicion_37 = primos.index(espejo_73) + 1 if espejo_73 in primos else None

#Espejo de la posición de 37
espejo_posicion_37 = espejo(posicion_37) if posicion_37 else None

#Verificamos si el primo en la posición espejo es 73
cumple_condicion_c = False
if espejo_posicion_37 and espejo_posicion_37 <= len(primos):
    cumple_condicion_c = primos[espejo_posicion_37 - 1] == numero
# Imprimir resultados
print(f"Espejo de {numero}: {espejo_73}")
print(f"Posición de {espejo_73} en la lista de primos: {posicion_37}")
print(f"Espejo de la posición de {espejo_73}: {espejo_posicion_37}")
print(f"¿El número primo en la posición {espejo_posicion_37} es {numero}?: {cumple_condicion_c}")
print(f"¿Cumple el número {numero} la condición c?: {cumple_condicion_c}")